# 正则

## 什么是正则

### 概述：正则是匹配模式，要么匹配字符，要么匹配位置。

## 正则表达式字符匹配攻略

### 如果正则只有精确匹配是没多大意义的，比如 /hello/，也只能匹配字符串中的 "hello" 这个子串。
正则表达式之所以强大，是因为其能实现模糊匹配。

### 两种模糊匹配

- 横向模糊匹配

	- 横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。

- 纵向模糊匹配

	- 纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种 可能。

### 字符组

- 范围表示法
- 排除字符组

	- 纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是 "a"、"b"、"c"。
	- 此时就是排除字符组(反义字符组)的概念。例如 [^abc]，表示是一个除 "a"、"b"、"c"之外的任意一个字 符。字符组的第一位放 ^(脱字符)，表示求反的概念。

- 字符组常见的简写形式

	- 概述：有了字符组的概念后，一些常见的符号我们也就理解了。因为它们都是系统自带的简写形式。
	- 简写形式

		- \d

			- 表示 [0-9]。表示是一位数字。 记忆方式:其英文是 digit(数字)

		- \D

			- 表示 [^0-9]。表示除数字外的任意字符。

		- \w

			- 表示 [0-9a-zA-Z_]。表示数字、大小写字母和下划线。 记忆方式:w 是 word 的简写，也称单词字符。

		- \W

			- 表示 [^0-9a-zA-Z_]。非单词字符。

		- \s

			- 示 [ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页 符。
记忆方式:s 是 space 的首字母，空白符的单词是 white space。

		- \S

			- 表示 [^ \t\v\n\r\f]。 非空白符。

		- .

			- 表示 [^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符 除外。
记忆方式:想想省略号 ... 中的每个点，都可以理解成占位符，表示任何类似的东西

		- 拓展

			- 如果要匹配任意字符怎么办?可以使用 [\d\D]、[\w\W]、[\s\S] 和 [^] 中任何的一个。

### 量词

- 简写形式

	- {m,}

		- 表示至少出现 m 次

	- {m}

		- 等价于 {m,m}，表示出现 m 次

	- ?

		- 等价于 {0,1}，表示出现或者不出现。 记忆方式:问号的意思表示，有吗?

	- +

		- 等价于 {1,}，表示出现至少一次。 
记忆方式:加号是追加的意思，得先有一个，然后才考虑追加

	- *

		- 等价于 {0,}，表示出现任意次，有可能不出现。 记忆方式:看看天上的星星，可能一颗没有，可能零散有几颗，可能数也数不过

- 贪婪匹配与惰性匹配

	- 贪婪匹配

		- 贪婪量词

			- {m,n}
			- {m,}
			- ?
			- +
			- *

	- 惰性匹配

		- 通过在量词后面加个问号就能实现惰性匹配
		- 惰性量词

			- {m,n}?
			- {m,n}?
			- ??
			- +?
			- *?

### 多选分支

- 一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。

## 正则表达式的拆分

### 概述：正则这门语言跟其他语言有一点不同，它通常就是一大堆字符，而没有所谓“语句”的概念，如何能正确地把一大串正则拆分成一块一块的，成为了破解“天书”的关键

### 结构和操作符

- 概述：编程语言一般都有操作符。只要有操作符，就会出现一个问题。当一大堆操作在一起时，先操作谁，又后操
作谁呢?为了不产生歧义，就需要语言本身定义好操作顺序，即所谓的优先级
- 结构

	- 字面量
	- 字符组
	- 量词
	- 锚
	- 分组
	- 分支

- 操作符

	- 操作符都体现在结构中，即由特殊字符和普通字符所代表的一个个特殊整体

### 注意要点

- 匹配字符串整体问题

	- 因为是要匹配整个字符串，我们经常会在正则前后中加上锚 ^ 和 $。

- 量词连缀问题
- 元字符转义问题

	- 所谓元字符，就是正则中有特殊含义的字符。
	- ^、$、.、*、+、?、|、\、/、(、)、[、]、{、}、=、!、:、- ,
	- 当匹配上面的字符本身时，可以一律转义:

## 正则表达式回溯法原理

### 介绍

- 学习正则表达式，是需要懂点儿匹配原理的。

### 概述：简单总结就是，正因为有多种可能，所以要一个一个试。直到，要么到某一步时，整体匹配成功了;要么最 后都试完后，发现整体匹配不成功

###  常见的回溯形式

- 贪婪量词
- 惰性量词
- 分支结构

	- 我们知道分支也是惰性的，比如 /can|candy/，去匹配字符串 "candy"，得到的结果是 "can"，因为分支会
一个一个尝试，如果前面的满足了，后面就不会再试验了
	- 分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分
支。这种尝试也可以看成一种回溯

## 正则表达式括号的作用

### 分组和分支结构

- 概述：这二者是括号最直觉的作用，也是最原始的功能，强调括号内的正则是一个整体，即提供子表达式。
- 分组

	- 我们知道 /a+/ 匹配连续出现的 "a"，而要匹配连续出现的 "ab" 时，需要使用 /(ab)+/。

- 分支结构

	- 而在多选分支结构 (p1|p2) 中，此处括号的作用也是不言而喻的，提供了分支表达式的所有可能。

### 分组引用

- 概述：这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强大的替换操作。
- 而要使用它带来的好处，必须配合使用实现环境的 API。比如使用replace,我们就引用到分组
- 正则引擎也是这么做的，在匹配过程中，给每一个分组都开辟一个空间，用来存储每一个分组匹配到的
数据

### 反向引用

- 除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用。
- \1表示第一个分组 \2表示第二个分组
- 引用不存在的分组会怎样?

	- 
因为反向引用，是引用前面的分组，但我们在正则里引用了不存在的分组时，此时正则不会报错，只是匹配 反向引用的字符本身。例如 \2，就匹配 "\2"。注意 "\2" 表示对 "2" 进行了转义

- 分组后面有量词会怎样?

	- ❗️分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配
	- 同理对于反向引用，也是这样的
	- 注意(\d)+不是有很多个分组 实际上就只有一个分组 分组的多少由括号决定的 

### 捕获括号

- 之前文中出现的括号，都会捕获它们匹配到的数据

### 非捕获括号

- 如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。
- 此时可以使用非捕获括号 (?:p) 和 (?:p1|p2|p3)

## 正则表达式位置匹配攻略

###  什么是位置?

- 位置(锚)是相邻字符之间的位置

### 如何匹配位置?

- 在 ES5 中，共有 6 个锚

	- ^

		- (脱字符)匹配开头，在多行匹配中匹配行开头）

	- $

		- (美元符号)匹配结尾，在多行匹配中匹配行结尾)

	- \b 

		- \b 是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置。

	- \B 

		- 就是 \b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \b，剩下的都是 \B 的。
		- 具体说来就是 \w 与 \w、 \W 与 \W、^ 与 \W，\W 与 $ 之间的位置

	- (?=p)

		- (?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p。
		- 比如 (?=l)，表示 "l" 字符前面的位置
		- 正向前瞻：(?=exp)，匹配的是自身出现的位置`后面能匹配` exp

	- (?!p)

		- (?!p) 就是 (?=p) 的反面意思
		- 负向前瞻：(?!exp)，匹配的是自身出现的位置`后面不能匹配` exp

	- (?<=)

		- 正向后顾：(?<=)，匹配的是自身出现的位置`前面能匹配` exp

	- (?<!)

		- 负向后顾：(?<!)，匹配的是自身出现的位置`前面不能匹配` exp

### 位置的特性

- 概述：对于位置的理解，我们可以理解成空字符 ""
- 因此位置可以用来规定后面的字符是以什么的规则存在的
- ❗️正则表达式中添加位置字符也是起到了限制过滤作用

## 相关API

*XMind - Trial Version*