# Typescript

## TypeScript是什么

### 概述：TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。

### 理解：你可以把它当做一门新的编程语言，重新认识它如何定义变量、声明类型而不是单单理解成只有类型提示的作用

## 从 JavaScript 迁移

### 添加一个 tsconfig.json 文件

### 把文件扩展名从 .js 改成 .ts，开始使用 any 来减少错误

### 开始在 TypeScript 中写代码，尽可能的减少 any 的使用

### 回到旧代码，开始添加类型注解，并修复已识别的错误

### 为第三方 JavaScript 代码定义环境声明

### 配置对应的eslint或者tslint

### 我来做迁移：原有的JS文件不变基于原来的持续进行迭代

## TypeScript基础类型

### TypeScript你理解成一门新的编程语言（代替JS,所以项目引入ts,你应该意识是用ts开发，所以还得TS这门语言是否有支持），这个编程语言如何声明自己的变量

###  Boolean 类型

- let isDone: boolean = false

### Number 类型

- let count: number = 10

### Array 类型

- let list: number[] = [1, 2, 3]

### String类型

### Object

- 我们希望一个变量或者函数的参数的类型是一个对象的时候就可以使用它

### Symbol

### Enum 类型

- 使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举
- 实际上，当我们在声明 enum Direction 时，除了会创建一个名为 Direction 的枚举变量之外，同时也创建了一个名为 Direction 的类型
- 枚举类型

	- 数字枚举
	- 字符串枚举
	- 异构枚举

		- 简单来说异构枚举就是枚举值中成员值既有数字类型又有字符串类型

### Any 类型

- 在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型（也被称作全局超级类型)
在许多场景下，这太宽松了。使用 any 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 any 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown 类型

### Unknown 类型

- 就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）,使用Unkown代替any
- 区别：unknown 类型要安全得多，因为它迫使我们执行额外的类型检查来对变量执行操作。

### Tuple 类型

- 众所周知，数组一般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。
- 实际业务中数组元素类型一致

### Void 类型

- void 和 any 相反，any 是表示任意类型，而 void 是表示没有任意类型，就是什么类型都不是，这在我们定义函数，函数没有返回值时会用到

### Null类型

### Undefined 类型

### Never 类型

- never 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型

### 评价：更加细分了变量类型 不像JS把变量分为原始类型和引用类型

## TypeScript泛型

### 概述：泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性

### 理解

- 平时我们都是对值进行编程，泛型是对类型进行编程
- 何时使用

	- 输入输出的时候就要考虑用到泛型，只有输出我们才会用到这个泛型实参，并且可以使用泛型代替any

### 支持创建泛型的方式

- 泛型接口
- 泛型类
- 泛型数组
- 泛型工具类型

### 泛型变量

- T（Type）：表示一个 TypeScript 类型
- K（Key）：表示对象中的键类型
- V（Value）：表示对象中的值类型
- E（Element）：表示元素类型

### 泛型约束

- 当我们使用了泛型时，就意味着这个这个类型是任意类型。但在大多数情况下，我们的逻辑是对特定类型处理的。
- 泛型约束就是使用一个类型和extends对泛型进行约束

## TypeScript类

### 实际上，当我们在声明 class Point 时，除了会创建一个名为 Point 的类之外，同时也创建了一个名为 Point 的类型（实例的类型）

### 接口继承类

### 类实现接口

## TypeScript接口

### 概述：
TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述

### 对象的形状

### 可选 | 只读属性

### 函数类型

- 接口可以描述普通对象，还可以描述函数类型

### 声明合并

### 接口的高阶用法

- 索引签名

	- 当你声明一个索引签名时，所有明确的成员都必须符合索引签名

- 继承接口
- 混合类型接口

## Typescript函数

### 定义 TS 函数的四种方式

### 可选参数

### 参数默认值

### 函数重载

- 要求定义一系列的函数声明，在类型最宽泛的版本中实现重载， TS 编译器的函数重载会去查询一个重载的列表，并且从最开始的一个进行匹配，如果匹配成功，就直接执行。所以我们要把大概率匹配的定义写在前面

## 高级类型

### 交叉类型

- 联合类型是要求只要符合联合类型中任意一种类型即可，它使用 | 符号定义。当我们的程序具有多样性，元素类型不唯一时，即使用联合类型

### 联合类型

- 交叉类型就是取多个类型的并集，使用 & 符号定义，被&符链接的多个类型构成一个交叉类型，表示这个类型同时具备这几个连接起来的类型的特点

### 索引类型

### 映射类型

### 条件类型

## 类型别名和字面量类型

### 字面量类型

- 字符串字面量类型
- 数字字面量类型

### 类型别名

- 类型别名就是给一种类型起个别的名字，之后只要使用这个类型的地方，都可以用这个名字作为类型代替，但是它只是起了一个名字，并不是创建了一个新类型
- 使用type关键字定义类型别名
- 类型别名也可以使用泛型
- ❗️就是我们一直使用的type 

### 类型别名type和接口interface的区别

- 共同点：
都可以描述一个对象或者函数
interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。
- 不同点

	- ttype 可以声明基本类型别名，联合类型，元组等类型而 interface 不行

		- type Name = string;

let username: Name = "vnues";

	- interface 能够声明合并而 type 不行

## TypeScript类型守卫

### 概述：指的是 TypeScript 能够在特定的区块(类型保护区块)中保证变量属于某种特定的类型。可以在此区块中放心地引用此类型的属性，或者调用此类型的方法

### in 关键字

### typeof 关键字

###  instanceof 关键字

### 类型谓词

## TypeScript断言

### 概述：
有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型

### “尖括号” 语法

### as 语法

## TypeScript关键字

### typeof

- 在 TypeScript 中，typeof 操作符可以用来获取一个变量声明或对象的类型
对比JS的typeof（❗️是同个关键字）来说 即可用来判断类型 同时还会获取其类型，TS对其做了拓展

### keyof

- keyof 操作符可以用来一个对象中的所有 key 值

### infer

- 在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用

### extends

- 有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束

## 自由主题

### 被typeof判断的类型 就可以明确它就是那种类型了 类似 pet is Object (用户自定义的类型保护)

### 为这个类声明接口，为这个方法声明接口

### 声明空间

- 在 TypeScript 里存在两种声明空间：类型声明空间与变量声明空间。下文将分别讨论这两个概念
- 类型声明空间
- 变量声明空间

### import/require 仅仅是导入类型

- import foo from foo'
它实际上只做了两件事

	- 导入 foo 模块的所有类型信息
	- 导入 foo 模块的所有类型信息；

- 如果你没有把导入的名称当做变量声明空间来用，在编译成 JavaScript 时，导入的模块将会被完全移除。这最好用例子来解释，下面我们将会给出一些示例
- 我的理解 我们一般导出的就是一个类或者方法 变量啊 所以需要为他们声明接口 比如Button类的接口 就是一个对应为Button的接口 我们引入的时候引入是它的接口 如果有使用它 编译阶段就是当做变量声明空间来使用
- 这个解答了就是明明我们想导入是React类 偏偏点进去是一个接口类型 注意声明的接口类型不能当做变量来使用 我觉得它编译阶段会先去找 有没有存在这个变量 找不到 就报错
- 这也就是为什么有时候第三方没有提供声明文件，我们引入会报不存在 因为import/require 仅仅是导入类型 所以解决方法是在全局下声明一个给它 
- 类型声明空间的空间

	- 其实应该回到这个问题上，我们为什么需要ts
	- ❗️才能获得对应的代码补全、接口提示等功能
	- 提供类型检测，类型支持，当我们使用一个方法，如果该函数提供对应的类型接口，我们就可以知道要传递多少个参数 参数是什么类型（编辑器的支持）

- 编辑器

	- 如果你写的方法等有提供接口 vscode默认支持会去读这个接口的
	- 如果没有 你会发现command+点击以后进去的就是你写的这个方法
	- 评价：智能

- 所以你要知道在TS这门语言中，类型声明和变量声明应该是同个地位 也很重要 也提供了 专门用于处理类型的API 比如Omit

### 学习为第三方 JavaScript 库编写环境声明，是一种为 TypeScript 写注解比较好的实践方式

### 面试可能会问 如何从js迁移到ts

### 此外ts也可以引入新的语法特性 也行的 毕竟可以当做是一门新的编程语言

### 

### declare

- 声明全局？
- 你可以通过 declare 关键字来告诉 TypeScript，你正在试图表述一个其他地方已经存在的代码，如：写在 JavaScript、CoffeeScript 或者是像浏览器和 Node.js 运行环境里的代码：
- 假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 <script> 标签引入 jQuery，然后就可以使用全局变量 $ 或 jQuery 了。 没有通过import Jquery from 'xxx'

	- 但是在 ts 中，编译器并不知道 $ 或 jQuery 是什么东西1

- 在所有的声明语句中，declare var 是最简单的，如之前所学，它能够用来定义一个全局变量的类型。与其类似的，还有 declare let 和 declare const，使用 let 与使用 var 没有什么区别：

❗️作用：定义一个全局变量的类型  这样已解释就通了
- 因为一般我们是直接声明接口的 然后变量声明的指定具体类型 比如 let a:number

### 把类当做接口使用

- 如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类

*XMind - Trial Version*