#### 什么是同源策略有什么限制？

- 限制一个源加载文件或者脚本到另一个源资源进行的交互

- 源：协议，域名和端口有一个不同则为跨域
- 限制：
  - cookie，localstorage 和 indexDB 无法获取
  - 无法获取和操作 DOM
  - 不能发送 Ajax 请求，ajax 只适合同源策略

#### 前后端通信的几种方式

- Ajax：不支持跨域
- WebSocket：不受同源策略的限制，支持跨域
- CORS：不受同源策略的限制，支持跨域，新的通信方式



#### 如何创建 Ajax

回答几个问题：

1. XMLHttpRequest 的工作原理（发送 Ajax 的五个步骤）

   1. 创建 XMLHttpRequest 异步对象
   2. 使用 open 方法设置请求参数，open(method，url，是否异步)
   3. 发送请求 send() 
   4. 注册事件 onreadystatechange 事件，状态改变的时候调用，收据完整请求回来的时候回调用，需要手动写一些逻辑判断
   5. 获取返回数据，更新UI

2. 兼容性处理

   ```js
   var xhr = XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject('Microsoft.XMLHTTP')
   ```

3. 事件的触发条件

   1. xhr.onreadystatechange 变化
      - readyState 状态
      - 0：请求未初始化
      - 1：服务器连接已简历
      - 2：请求已接收
      - 3：请求处理中
      - 4：请求已完成，且响应已就绪
   2. xhr.onloadstart 上传阶段
   3. xhr.upload.onload 下载阶段

4. 事件的触发顺序

   - 触发变化  - 上传  -下载

简单的实现 ajax

```js
//1.创建异步对象
var xhr = new XMLHttpRequset()
//2.设置请求参数open
xhr.open('get','url',true) 
//        设置请求头，post必传
xhr.setReqyestHeader()
//3.发送请求
xhr.send()
//4.注册事件
xhr.onreadystatechange = function() {
    //判断是否请求成功
    if (xhr.readyState == 4 & xhr.status == 200) {
        requestData()
    }
}
//5.返回请求数据
function requestData() {
    console.log(xhr.responseText)
}
```

Ajax 的封装 

```js
function ajax() {
    // 传参
    var ajaxData = {
        type: (arguments[0].type || "GET").toUpperCase(),
        url: arguments[0].url || "",
        async: arguments[0].async || "true",
        data: arguments[0].data || null,
        dataType: arguments[0].dataType || "json",
        contentType: arguments[0].contentType || "application/x-www-form-urlencoded; charset=utf-8",
        beforeSend: arguments[0].beforeSend || function () { },
        success: arguments[0].success || function () { },
        error: arguments[0].error || function () { }
    }

    ajaxData.beforeSend()
    // 创建异步对象
    var xhr = createxmlHttpRequest();
    // 响应文件类型
    xhr.responseType = ajaxData.dataType;
    // 发送请求
    xhr.open(ajaxData.type, ajaxData.url, ajaxData.async);
    // 设置请求头
    xhr.setRequestHeader("Content-Type", ajaxData.contentType);

    xhr.send(convertData(ajaxData.data));

    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
            if (xhr.status == 200) {
                ajaxData.success(xhr.response)
            } else {
                ajaxData.error()
            }
        }
    }
}

function createxmlHttpRequest() {
    if (window.ActiveXObject) {
        return new ActiveXObject("Microsoft.XMLHTTP");
    } else if (window.XMLHttpRequest) {
        return new XMLHttpRequest();
    }
}

function convertData(data) {
    if (typeof data === 'object') {
        var convertResult = "";
        for (var c in data) {
            convertResult += c + "=" + data[c] + "&";
        }
        convertResult = convertResult.substring(0, convertResult.length - 1)
        return convertResult;
    } else {
        return data;
    }
}

ajax({
    type: "Post",
    url: "https://mock.yonyoucloud.com/mock/15579/post",
    dataType: "json",
    data: {
        "name": "abc",
        "age": 123,
        "id": "456"
    },
    beforeSend: function () {
        //some js code 
    },
    success: function (msg) {
        console.log(msg)
    },
    error: function () {
        console.log("error")
    }
})
```



#### 跨域通信的几种方式？

- JSONP

  - JSONP 的原理是什么？怎么实现的？
  - 原理：通过 script 标签的异步加载来实现

  ```js
  <script src='url'> </script>
  ```

  实现

  ```js
  let count = 1
  export default function originPJSONP (option) {
      // 1.从传入的option中提取URL
      const url = option.url
      // 2.在body中添加script标签
      const body = document.querySelector('body')
      const script = document.createElement('script')
      // 3.内部生成一个不重复的callback
      const callback = 'jsonp' + conut++
      // 4.监听window上的jsonp的调用
      return new Promise((resolve, reject) => {
          try {
              window[callback] = function (result) {
                  body.removeChild(script)
                  resolve(result)
              }
              const params = handleParam(option.data)
              script.src = url + '?callback' + callback + params
              body.appendChild(script) 
          } catch (err) {
              body.removeChild(script)
              reject(err)
          }
      })
  }
  function handleParam (data) {
      let url =''
      for (let key in data) {
          let value = data[key] !== undefined ? data[key]:''
          url += `&${key}=${encodeURIcomponent(value)}`
      }
      return url
  }
  ```

  

- WebSocket

  - 为什么使用 webSocket ？
    - 已经有HTTP协议了，为什么还要 webSocket 协议，因为 http 协议存在缺陷，只能从客服端发起，不能通过服务端主动发起
    - 特点：
      1. 简历在 TCP 协议之上，服务端实现比较容易
      2. 与 HTTP 协议有着良好的兼容性，默认端口是 80 和 443 
      3. 数据格式比较轻量，性能开销小，通信高效
      4. 可以发送文本，二进制数据
      5. 没有同源限制，客服端可以与任意服务器通信

  简单使用

  ```js
  // 创建WebSocket对象
  var ws = new WebSocket('wss://echo.websocket.org')
  // 1.开始阶段
  ws.onopen = function(evt) {
      console.log("connection open ...")
      ws.send('Hello WebSoket')
  }
  // 2.信息
  ws.onmessage = function(evt) {
      console.log("Received Message:" + evt.data)
      ws.close()
  }
  // 3.清除
  ws.onclose = function(evt) {
      console.log("connection closed")
  }
  ```

  

- CORS

  - 是 W3C 的一个标准，跨域资源共享，主要客服了 AJAX 只能同源的限制
  - 需要浏览器和服务器的同时支持，服务器实现了 CORS 接口，就可以跨域通信

- Hash

  - url的`#`后面的内容就叫Hash。**Hash的改变，页面不会刷新**。这就是用 Hash 做跨域通信的基本原理

- postMessage

  - H5中新增的postMessage()方法，可以用来做跨域通信

- vue-axios 原理

  - 