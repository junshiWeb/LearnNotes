#### 1. 原型链继承

```js
function Person() {
  this.name = 'fun'
  this.arr = [1, 2, 3]
}

function Son(type) {
  this.type = type
}
Son.prototype = new Person()


```

- 原理：利用原型链向上查找的特点，给 obj.prototype 赋值父类的一个实例，在子类访问的时候就会查找父类的函数的属性

> 缺点：
>
> 1. 原型链的继承会造成属性修改混合
> 2. 同时子类的实例不能像父类添加参数和传参

#### 2. 构造函数继承

```js
function Person(name) {
  this.name = name
  this.age = 18
  this.say = function() {
    console.log(this.age);
  }
}

function Son(name) {
  // 要放在开头
  Person.call(this)
}
var son = new Son('son')
```

- 原理：通过 call 实现的继承修改 this 的指向，让父类的 this 指向子类的上下文，这样父类的属性和方法也会写到子类上面

> 优点：解决了原型链继承不能添加参数的问题
>
> 缺点：
>
> 1. 和构造函数模式一样，所有的方法都在构造函数中定义，不能复用
> 2. 只能继承父类构造函数上的属性和方法，父类原型新增的属性和方法不能继承

#### 3. 组合继承

```js
function Person(name, age) {
  this.name = name
  this.age = age
  this.say = function() {
    console.log(this.age);
  }
}
Person.prototype.sayName = function() {
  console.log(this.name)
}
function Son(name, age) {
  // 继承属性
  Person.call(this)
  this.age = age
}
// 继承方法
Son.prototype = new Person()
Son.prototype.constructor = Son
Son.prototype.sayAge = function() {
  console.log(this.age)
}
```

- 原理：通过 call 改变 this 的上下文，在通过 Son.prototype = new Person() 实现继承父类原型上的属性和方法

> 优点：解决了原型继承和构造函数继承的无法传参的问题
>
> 缺点：
>
> 1. 通过 new 构造创建构造函数，会执行两次父类（一次是 call()，一次是new Person()）的构造函数，，导致子类的原型对象中添加了不必要的属性和方法，造成内存上的浪费

组合继承的第二种方式

```js
Son.prototype = Person.prototype
```

> 优点：解决了创建两次父类构造函数的问题
>
> 缺点：造成了子类和父类的实例无法区分

#### 4. 寄生式继承

```js
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
// 在object()函数内部,先创建一个临时性的构造函数,然后将传入的对象作为这个构造函数原型,最后返回了这个临时类型的一个新实例.
// object()本质上对其中传入的对象进行了一次浅复制
// 看如下的例子:
var person = {
  name: "kebi",
  friends: ["kuli", "hadeng"]
};
var son = object(person);
```

- 原理：

> 优点：对象不是自定义类型和构造函数的情况实现简单继承
>
> 缺点：在为对象添加函数的时候，没办法做到函数的复用

#### 5. 寄生式组合继承

```js
function inheritPrototype(son, person){
	// 创建原型对象是超类原型对象的一个实例对象
  var prototype = object(person.prototype); 
	// 弥补因为重写原型而失去的默认的 constructor 属性。
  prototype.constructor = son; 
	// 实现原型继承
  son.prototype = prototype; 
}
```

- 原理：

> 优点：效率高，避免了在 SubType.prototype 上创建不必要的属性。与此同时还能保持原型链不变

#### 6. ES6：class

